#!/bin/bash
version="0.5.0"
copyright="Copyright (c) 2012 Ryoichi KATO <ryo1kato@gmail.com>"
#
# This is free software; you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free
# Software Foundation; either version 2, or (at your option) any later
# version.
#
# This is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
# for more details.
#

##############################################################################
# To change the script behavior, modify these environment variables.
##############################################################################

# Where deleted file goes, and place of log file.
TRASHDIR="${TRASHDIR:="$HOME/.TRASH"}"
TRASHLOG="$TRASHDIR/trash.log"
trash_keep_days="${trash_keep_days:=14}"



##############################################################################
##             You don't have to modify lines hereafter.
##############################################################################
DATE=`date +%Y-%m-%d` # YYYY-MM-DD
TIME=`date +%H:%M:%S` # hour:minitute:second

# define a function for displaying help.
program_name="${0##*/}"
print_help () {
echo "\
Usage: $program_name [OPTIONS] FILE1 [FILE2 ...]
       $program_name [OPTIONS] --clean[=DAYS]
       $program_name [--help|--version]
OPTIONS
  -v,--verbose   Show filename as it is being deleted.
  -h,--help      Show this help.
  -V,--version   Show version information.
  --clean[=DAYS] Clean up files older than DAYS(default 14) in $TRASHDIR
DESCRIPTION
  Safer 'rm'; mv files to \$TRASHDIR($TRASHDIR) instead of
  actually unlinking them.
"
}
print_copyright () {
        echo "$program_name $version, Written by Ryoichi Kato."
        echo
        echo "$copyright"
        echo "This is free software; see the source for copying conditions."
        echo "There is NO warranty; not even for MERCHANTABILITY or FITNESS"
        echo "FOR A PARTICULAR PURPOSE."
}

DIE () {
    echo "$program_name: ERROR: $*" >&2
    exit 1
}

print_verbose () {
    if [ "$opt_verbose" = yes ]; then
        echo "$program_name: $*"
    fi
}

clean_trash () {
    typeset -i keep_days="$1"
    if [ "$opt_verbose" = yes ]; then
        typeset find_print='-print'
    fi

    if [ "$keep_days" -gt 1 ]; then
        find "${TRASHDIR}" -maxdepth 1 -ctime +"$keep_days" -exec rm -rf '{}' \; $find_print
    else
        DIE "DAYS to --clean must be more than 2"
    fi
}


##
## parse command line options
##
while [ $# -gt 0 ]
do
case $1 in
    "") DIE "ERROR: Too few argement";;
    -h|--help)    print_help;      exit 0;;
    -V|--Version) print_copyright; exit 0;;
    -v|--verbose) opt_verbose=yes;;
    --clean=*)
        clean_trash "${1#--clean=}"
        exit $?;;
    --clean)
        if [ -n "$2" ]; then
            clean_trash "$2"
        else
            clean_trash "$trash_keep_days"
        fi
        exit $?;;
    --) shift; continue;;
    -*) DIE "Unknown option: '$1'";;
    *)  break;;
esac
shift
done

##
## Check the existence of $TRASHDIR
##
if [ ! -d "$TRASHDIR" ]; then
    echo "INFO: $TRASHDIR doesn't exist. Creating." >&2
    mkdir -p "$TRASHDIR" || { echo "could not mkdir $TRASHDIR"; exit 1 ;}
    chmod 700 "$TRASHDIR" || { echo "could not chmod $TRASHDIR"; exit 1 ;}
fi

##
## Do it for each files
##
for FILENAME in "$@"
do
    # remove trailing "/" char.
    #FILENAME=`echo $FILENAME | sed -e "s/\/$//"`
    #NAME=`basename "$FILENAME"`
    FILENAME=${FILENAME%/}
    NAME=${FILENAME##*/}

    ## get original path for log
    case $FILENAME in
        /*)
            # if $FILENAME begin with "/", it is absolute path.
            ORIGINAL_PATH="$FILENAME"
            ;;
        *)
            # else, $FILENAME is relative path.
            ORIGINAL_PATH="$PWD/$FILENAME"
            ;;
    esac

    # if the file is symlink or empty, simply remove it.
    if [ -L "$FILENAME" ]; then
       print_verbose "unlink symlink: $FILENAME"
       rm "$FILENAME"
       continue
    fi
    if [ ! -s "$FILENAME" ]; then
       print_verbose "unlink empty: $FILENAME"
       rm "$FILENAME"
       continue
    fi

    # suffix to avoid dupulicated file name in TRASH
    NUMBER=1
    NAMEINTRASH="$DATE-$NUMBER-$NAME"

    # As without locking mechanismx, there can be race condition.
    # When two 'del' process run simultaneously and try to mv files
    # with same filename.
    # But I think it won't happen in most cases because this small
    # utility is intended to be run directly by terminal-user,
    # and normal user won't invoke script like this twice at the
    # same time.

    # increment suffix if the filename "$NAMEINTRASH" already exists.
    while  [ -e "$TRASHDIR/$NAMEINTRASH" ]
    do
           # if your shell doesn't support (()) notation,
           # comment it out and uncomment next line.
           # NUMBER=`expr $NUMBER + 1`  # for non Korn shell systems.
           ((NUMBER++))      # ksh, bash, zsh.
           NAMEINTRASH="$DATE-$NUMBER-$NAME"
    done

    # OK, now mv the file to $TRASH!
    if mv "$FILENAME" "$TRASHDIR/$NAMEINTRASH"; then
        msg="$DATE:$TIME:$ORIGINAL_PATH --> $NAMEINTRASH"
        echo "$msg" >> "$TRASHLOG"
        if [ "$opt_verbose" = yes ]; then
            print_verbose "$msg"
        fi
    else
        echo "Got error!" >&2
        exit 1
    fi
done
